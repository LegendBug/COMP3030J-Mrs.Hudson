{% extends 'Public/base.html' %}
{% load crispy_forms_filters %}
{% load crispy_forms_tags %}
{% load static %}

{% block extra_head %}
    <title>Watson Overseer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{% static 'css/Statistic/monitor.css' %}">
{% endblock %}

{% block extra_nav_icons %}
    <!-- åœ¨è¿™é‡Œæ·»åŠ å¯¼èˆªæ é‡Œé¢å¤–çš„icon-->
    {% if user.is_authenticated and user_type == 'Manager' %}
        <li class="nav-item">
            <a class="nav-link" href="{% url 'Statistic:statistic' %}" title="Statistic"><i class="fas fa-chart-bar fa-lg"></i> </a>
        </li>
        <li class="nav-item">
            <a class="nav-link" href="{% url 'Layout:layout' %}" title="Layout"><i class="fas fa-edit fa-lg"></i> </a>
        </li>
    {% endif %}
{% endblock %}

{% block breadcrumbs %}
    <nav aria-label="breadcrumb">
        <ol class="breadcrumb">
            <li class="breadcrumb-item"><a href="{% url 'Venue:home' %}">Home</a></li>
            {% if user.is_authenticated and user_type == 'Manager' %}
                <li class="breadcrumb-item"><a
                        href="{% url 'Venue:venue' current_access.id %}">{{ current_access.name }}</a></li>
            {% endif %}
            <li class="breadcrumb-item active" aria-current="page">Watson Overseer</li>
        </ol>
    </nav>
{% endblock %}

{% block content %}
    <div id="monitor-app">
        <!-- Floating Action Button -->
        <button @click="toggleOffcanvas" class="btn btn-primary rounded shadow" id="toggle-offcanvas-btn"
                :style="buttonStyle">
            <i :class="offcanvasOpen ? 'fas fa-chevron-left' : 'fas fa-chevron-right'"></i>
        </button>
        
        <div class="d-flex justify-content-between align-items-center mb-3" id="venue-header">
            <div id="venue-name" class="venue-text logo-title">
                Current Venue: {{ current_access.name }}
            </div>
            <div class="dropdown">
                <button class="btn btn-secondary dropdown-toggle" type="button" id="dropdownFloorMenu"
                        data-bs-toggle="dropdown" aria-expanded="false">
                    Current Sector: [[ layers.length > 0 ? layers[0].name : 'Loading...' ]]
                </button>
                <ul class="dropdown-menu" aria-labelledby="dropdownFloorMenu">
                    {% for sector in sectors %}
                        {% comment %}ä½ å…ˆåˆ«æ€¥, è¿™é‡Œæ˜¯Pycharmçš„æ¨¡æ¿è¯­æ³•å‡ºç°äº†é—®é¢˜, è¿™é‡Œå…¶å®æ˜¯å¯ä»¥æ­£å¸¸è¿è¡Œçš„{% endcomment %}
                        <li><a class="dropdown-item" href="#"
                               @click="toggleSector({{ sector.pk }})">Sector {{ sector.name }}</a></li>
                    {% endfor %}
                </ul>
            </div>
        </div>

        <div id="konva-container" class="konva" style="margin: 1rem 3rem 1rem 3rem"></div>
        <!-- ç”¨äºå±•ç¤ºåœ¨ç”»æ¿ä¸Šé€‰ä¸­çš„KonvaElementæ‰€åœ¨çš„Layer -->
        <div id="tooltip" style="position: absolute; display: none; background: lightgrey; padding: 5px; border-radius: 3px;"></div>

        <!-- Offcanvas -->
        <div class="offcanvas offcanvas-start" data-bs-scroll="true" data-bs-backdrop="false" id="offcanvasScrolling"
             tabindex="-1"
             aria-labelledby="offcanvasScrollingLabel"
             :class="{'show': offcanvasOpen}" style="visibility: visible;">

            <div class="offcanvas-header">
                {# Dropdown: Sector#}
                <div class="offcanvas-dropdown">
                    <button class="btn btn-secondary dropdown-toggle" type="button" id="dropdownSectorMenu"
                            data-bs-toggle="dropdown" aria-expanded="false">
                        Select Sector
                    </button>
                    <ul class="dropdown-menu" aria-labelledby="dropdownSectorMenu">
                        {% for sector in sectors %}
                            {% comment %}æˆ‘çŸ¥é“ä½ æƒ³debug,ä½†è¿™ä¸ªé”™è¯¯ä¸å½±å“ç¨‹åºçš„æ­£å¸¸è¿è¡Œ,å•çº¯æ˜¯IDEå¯¹Djangoæ¨¡æ¿æ¸²æŸ“çš„é”™è¯¯æç¤º,ä½ å¯ä»¥å¿½ç•¥å®ƒ{% endcomment %}
                            <li><a class="dropdown-item" href="#"
                                   @click="toggleSector({{ sector.id }})">Sector {{ sector.name }}</a></li>
                        {% endfor %}
                    </ul>
                </div>

                {# æŒ‰é’®: Save#}
                <button type="button" class="btn btn-primary" @click="synchronizeElementsData()">Save</button>
            </div>

            <div class="offcanvas-body">
                <!-- Topå±‚çº§Accordion -->
                <div class="accordion" id="accordion">
                    <layer-component v-for="(layer, index) in layers" :key="layer.id" :layer="layer"
                                     @update-current-layer="setCurrentLayer" @update-current-element="setCurrentElement"
                                     @element-added="addElement" @data-updated="refreshData">
                    </layer-component>
                </div>
            </div>
        </div>
        
        <monitor-list :monitors="monitors" @open-api-modal="openApiDemoModal" @update-current-element="setCurrentElement"></monitor-list>

        <!-- Set Monitor Properties Modal -->
        <div class="modal fade" id="elementPropertiesModal" tabindex="-1" aria-labelledby="elementPropertiesModalLabel"
             aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="elementPropertiesModalLabel">Element Properties</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <!-- Form for element properties -->
                        <form id="elementPropertiesForm">
                            <!-- Element Name -->
                            <div class="mb-3">
                                <label for="elementName" class="form-label">Element Name</label>
                                <input type="text" id="elementName" class="form-control">
                            </div>
                            <!-- Is Online -->
                            <div class="mb-3 form-check">
                                <input type="checkbox" class="form-check-input" id="isOnline" checked>
                                <label class="form-check-label" for="isOnline">Is Online</label>
                            </div>
                            <!-- Transformable -->
                            <div class="mb-3 form-check">
                                <input type="checkbox" class="form-check-input" id="transformable" checked>
                                <label class="form-check-label" for="transformable">Transformable</label>
                            </div>
                            <!-- Draggable -->
                            <div class="mb-3 form-check">
                                <input type="checkbox" class="form-check-input" id="draggable" checked>
                                <label class="form-check-label" for="draggable">Draggable</label>
                            </div>
                        </form>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        <button type="button" class="btn btn-primary" @click="confirmElementProperties">Confirm</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Edit Monitor Properties Modal -->
        <div class="modal fade" id="editElementPropertiesModal" tabindex="-1"
             aria-labelledby="editElementPropertiesModalLabel" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="editElementPropertiesModalLabel">Edit Element Properties</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <!-- Form for element properties -->
                        <form id="editElementPropertiesForm">
                            <!-- Monitor Name -->
                            <div class="mb-3">
                                <label for="editedElementName" class="form-label">Element Name</label>
                                <input type="text" id="editedElementName" class="form-control">
                            </div>
                            <!-- Is Online -->
                            <div class="mb-3 form-check">
                                <input type="checkbox" class="form-check-input" id="editedIsOnline">
                                <label class="form-check-label" for="editedIsOnline">Is Online</label>
                            </div>
                            <!-- Transformable -->
                            <div class="mb-3 form-check">
                                <input type="checkbox" class="form-check-input" id="editedTransformable">
                                <label class="form-check-label" for="editedTransformable">Transformable</label>
                            </div>
                            <!-- Draggable -->
                            <div class="mb-3 form-check">
                                <input type="checkbox" class="form-check-input" id="editedDraggable">
                                <label class="form-check-label" for="editedDraggable">Draggable</label>
                            </div>
                        </form>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        <button type="button" class="btn btn-primary" @click="editElementProperties">Confirm</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- API Usage Modal -->
        <div class="modal fade" id="apiDemoModal" tabindex="-1" aria-labelledby="apiDemoModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="apiDemoModalLabel">API Usage Information</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div class="container">
                            <div class="card custom-modal"> <!-- ä½¿ç”¨CardåŒ…è£¹ -->
                                <p class="text-muted lead">The pictures captured by the camera are sent to the corresponding API, and the deep learning model on the back end will process the pictures and count the traffic in the pictures.</p>

                                <div class="card-body">
                                  <p class="api-endpoint mb-2">You can use the API endpoint below to send images:</p>
                                  <p class="api-endpoint mb-4">POST: <a href="#" class="text-info"> https://hostname/Statistic/monitor/capture/[monitor_id]/</a></p>
                                </div>

                                <p class="test-recognition mt-4 mb-3">Test the recognition effect of the model by uploading a crowd picture of the venue below:</p>
                            </div>
                        </div>
                        
                        <!-- Image upload area -->
                        <div class="card border-primary mb-3" style="cursor: pointer;">
                            <div class="card-body text-center" @click="$refs.fileInput.click()">
                                <i class="fas fa-upload fa-2x text-primary"></i>
                                <p class="card-text text-secondary">Click or drag and drop an image here to upload.</p>
                                <input ref="fileInput" type="file" @change="handleFileUpload" accept="image/*" class="d-none" id="file-upload">
                            </div>
                        </div>
                        
                        <!-- Display processed image and results -->
                        <div v-if="processedImage">
                            <p class="mt-2" style="text-align: center"><strong>Detected persons:</strong> [[ personCount ]]</p>
                            <img :src="'data:image/jpeg;base64,' + processedImage" alt="Processed Image" class="img-fluid">
                        </div>
                    </div>
                </div>
            </div>
        </div>


    </div>

{% endblock %}

{% block scripts %}
    <script>
        Vue.component('monitor-list', {
            props: ['monitors'],
            delimiters: ['[[', ']]'], // æ›´æ”¹Vueçš„æ’å€¼è¡¨è¾¾å¼å®šç•Œç¬¦
            template: `
                <div class="table-responsive" style="margin: 1rem 3rem 1rem 3rem; user-select: none">
                    <table class="table table-hover text-white">
                        <thead class="bg-dark">
                        <tr>
                            <th>Monitor</th>
                            <th>Monitor Name</th>
                            <th>Sector</th>
                            <th>Status</th>
                            <th>API Url <i class="fas fa-question-circle" data-bs-toggle="modal" data-bs-target="#apiModal" @click="openApiDemoModal"></i></th>
                        </tr> 
                        </thead>
                        <tbody>
                            <tr v-if="monitors.length === 0">
                                <td colspan="5" class="text-center text-white">No monitors found. ğŸ’¤</td>
                            </tr>
                            <tr v-else v-for="monitor in monitors" :key="monitor.id" @click="editMonitor(monitor)" :class="{'table-success': monitor.is_online, 'table-warning': !monitor.is_online}" style="cursor: pointer;">
                                <td><img :src="monitor.image" alt="No image" class="monitor-img img-thumbnail"></td>
                                <td>[[ monitor.name ]]</td>
                                <td>[[ monitor.layer.name ]]</td>
                                <td>[[ monitor.is_online ? 'Online' : 'Offline' ]]</td>
                                <td>POST: <a href='#' class="text-info">https://hostname/Statistic/monitor/capture/[[ monitor.id ]]/</a></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            `,
            methods: {
                openApiDemoModal() {
                    this.$emit('open-api-modal');
                },
                
                editMonitor(monitor) {
                    this.$emit('update-current-element', monitor);
                    // è®¾ç½®è¡¨å•å­—æ®µçš„å€¼
                    setTimeout(() => {
                        const attrs = JSON.parse(monitor.data).attrs;
                        document.getElementById('editedElementName').value = monitor.name;
                        document.getElementById('editedTransformable').checked = monitor.transformable;
                        document.getElementById('editedIsOnline').checked = monitor.is_online;
                        document.getElementById('editedDraggable').checked = attrs.draggable;
                    }, 0); // ä½¿ç”¨ setTimeout ç¡®ä¿åœ¨ Vue çš„ DOM æ›´æ–°å®Œæˆåè®¾ç½®è¡¨å•å€¼
                    $('#editElementPropertiesModal').modal('show');
                },
            }
        });
    
        Vue.component('layer-component', {
            props: ['layer'],
            delimiters: ['[[', ']]'], // æ›´æ”¹Vueçš„æ’å€¼è¡¨è¾¾å¼å®šç•Œç¬¦
            data: function () {
                return {
                    open: false,  // æ¯ä¸ªç»„ä»¶æ§åˆ¶è‡ªå·±çš„æ‰“å¼€çŠ¶æ€
                    isContextMenuVisible: false,  // ä¸Šä¸‹æ–‡èœå•æ˜¯å¦å¯è§
                    contextMenuX: '0px',  // ä¸Šä¸‹æ–‡èœå•çš„Xåæ ‡
                    contextMenuY: '0px',   // ä¸Šä¸‹æ–‡èœå•çš„Yåæ ‡
                };
            },
            template: `
              <div class="accordion-item">
                <h2 class="accordion-header">
                  <button class="accordion-button" type="button"
                          :class="{'collapsed': !open}"
                          @click="open = !open;"
                          @contextmenu.prevent="openContextMenu($event, layer)"
                          style="background-color: #8bc0fa;">
                    <i class="fas fa-layer-group" style="margin-right: 5px;"></i> <!-- æ·»åŠ å›¾æ ‡ -->
                    [[ layer.name ]]
                  </button>
                </h2>
                <div v-if="open" class="accordion-collapse">
                  <div class="accordion-body">
                    <layer-component v-for="(child, index) in layer.child_units" :key="index"
                                     :layer="child"
                                     @update-current-layer="$emit('update-current-layer', $event)"
                                     @update-current-element="$emit('update-current-element', $event)"
                                     @data-updated="$emit('data-updated', $event)"
                                     @element-added="$emit('element-added', $event)">
                    </layer-component>

                    <element-component v-for="(element, index) in layer.monitors" :key="index"
                                       :element="element"
                                       @update-current-element="$emit('update-current-element', $event)"
                                       @data-updated="$emit('data-updated', $event)">
                    </element-component>
                  </div>
                </div>

                <!-- ä¸Šä¸‹æ–‡èœå• -->
                <div v-show="isContextMenuVisible" :style="{top: contextMenuY, left: contextMenuX}"
                     class="list-group context-menu">
                  <a class="list-group-item list-group-item-action" ref="addElementButton"
                     @click="addElement(layer); closeContextMenu()"><i class="fas fa-plus-square"></i> Add Monitor</a>
                </div>
              </div>
            `,
            mounted() {
                // ç›‘å¬å…¨å±€ç‚¹å‡»äº‹ä»¶ï¼Œç”¨äºéšè—ä¸Šä¸‹æ–‡èœå•
                document.addEventListener('click', this.handleOutsideClick);
            },
            beforeDestroy() {
                // ç»„ä»¶é”€æ¯å‰ç§»é™¤äº‹ä»¶ç›‘å¬å™¨ï¼Œé¿å…å†…å­˜æ³„æ¼
                document.removeEventListener('click', this.handleOutsideClick);
            },
            methods: {
                handleOutsideClick(e) { // å…¨å±€ç‚¹å‡»äº‹ä»¶å¤„ç†
                    if (!e.target.closest('.context-menu')) {
                        this.isContextMenuVisible = false; // ä½¿ç”¨ this æŒ‡å‘ç»„ä»¶å®ä¾‹
                    }
                },

                openContextMenu(event) { // ä¸Šä¸‹æ–‡èœå•äº‹ä»¶å¤„ç†
                    event.preventDefault();
                    if (this.isContextMenuVisible) {
                        this.isContextMenuVisible = false;
                        // æ·»åŠ ä¸€ä¸ªå°å»¶è¿Ÿå†æ˜¾ç¤ºæ–°çš„èœå•ï¼Œä»¥ä½¿èœå•çš„éšè—å’Œæ˜¾ç¤ºæ›´åŠ æ˜æ˜¾
                        this.$nextTick(() => {
                            this.contextMenuX = event.clientX + 'px';  // æ ¹æ®äº‹ä»¶ä½ç½®è®¾ç½®ä¸Šä¸‹æ–‡èœå•çš„æ¨ªåæ ‡
                            this.contextMenuY = event.clientY + 'px';  // æ ¹æ®äº‹ä»¶ä½ç½®è®¾ç½®ä¸Šä¸‹æ–‡èœå•çš„çºµåæ ‡
                            this.isContextMenuVisible = true;  // æ˜¾ç¤ºä¸Šä¸‹æ–‡èœå•
                        });
                    } else {
                        this.contextMenuX = event.clientX + 'px';  // æ ¹æ®äº‹ä»¶ä½ç½®è®¾ç½®ä¸Šä¸‹æ–‡èœå•çš„æ¨ªåæ ‡
                        this.contextMenuY = event.clientY + 'px';  // æ ¹æ®äº‹ä»¶ä½ç½®è®¾ç½®ä¸Šä¸‹æ–‡èœå•çš„çºµåæ ‡
                        this.isContextMenuVisible = true;  // æ˜¾ç¤ºä¸Šä¸‹æ–‡èœå•
                    }
                },

                closeContextMenu() {
                    this.isContextMenuVisible = false;  // éšè—ä¸Šä¸‹æ–‡èœå•
                },

                addElement(layer) {
                    this.$emit('update-current-layer', layer);
                    this.$emit('element-added');
                }
            },
        });

        Vue.component('element-component', {
            props: ['element'],
            delimiters: ['[[', ']]'], // æ›´æ”¹Vueçš„æ’å€¼è¡¨è¾¾å¼å®šç•Œç¬¦
            data() {
                return {
                    open: false,
                    isContextMenuVisible: false, // æ§åˆ¶ä¸Šä¸‹æ–‡èœå•æ˜¾ç¤º
                    contextMenuX: '0px', // ä¸Šä¸‹æ–‡èœå•çš„æ¨ªåæ ‡
                    contextMenuY: '0px' // ä¸Šä¸‹æ–‡èœå•çš„çºµåæ ‡
                };
            },
            template:
                `
                  <div class="accordion-item">
                    <h2 class="accordion-header">
                      <button class="accordion-button" type="button"
                              @contextmenu.prevent="openContextMenu($event)"
                              style="background-color: #e36767;">
                        <i class="fas fa-cogs" style="margin-right: 5px;"></i>
                        [[ element.name ]]
                      </button>
                    </h2>
                    <!-- ä¸Šä¸‹æ–‡èœå• -->
                    <div v-show="isContextMenuVisible" :style="{top: contextMenuY, left: contextMenuX}"
                         class="list-group context-menu">
                      <a class="list-group-item list-group-item-action"
                         @click="openEditElement(element); closeContextMenu()">Edit Monitor</a>
                      <a class="list-group-item list-group-item-action"
                         @click="deleteElement(element); closeContextMenu()">Delete Monitor</a>
                    </div>
                  </div>
                `,
            mounted() {
                // ç›‘å¬å…¨å±€ç‚¹å‡»äº‹ä»¶ï¼Œç”¨äºéšè—ä¸Šä¸‹æ–‡èœå•
                document.addEventListener('click', this.handleOutsideClick);
            },
            beforeDestroy() {
                // ç»„ä»¶é”€æ¯å‰ç§»é™¤äº‹ä»¶ç›‘å¬å™¨ï¼Œé¿å…å†…å­˜æ³„æ¼
                document.removeEventListener('click', this.handleOutsideClick);
            },
            methods: {
                handleOutsideClick(e) { // å…¨å±€ç‚¹å‡»äº‹ä»¶å¤„ç†
                    if (!e.target.closest('.context-menu')) {
                        this.closeContextMenu();
                    }
                },

                openContextMenu(event) {
                    event.preventDefault();
                    if (this.isContextMenuVisible) {
                        this.isContextMenuVisible = false;
                        // æ·»åŠ ä¸€ä¸ªå°å»¶è¿Ÿå†æ˜¾ç¤ºæ–°çš„èœå•ï¼Œä»¥ä½¿èœå•çš„éšè—å’Œæ˜¾ç¤ºæ›´åŠ æ˜æ˜¾
                        this.$nextTick(() => {
                            this.contextMenuX = event.clientX + 'px';  // æ ¹æ®äº‹ä»¶ä½ç½®è®¾ç½®ä¸Šä¸‹æ–‡èœå•çš„æ¨ªåæ ‡
                            this.contextMenuY = event.clientY + 'px';  // æ ¹æ®äº‹ä»¶ä½ç½®è®¾ç½®ä¸Šä¸‹æ–‡èœå•çš„çºµåæ ‡
                            this.isContextMenuVisible = true;  // æ˜¾ç¤ºä¸Šä¸‹æ–‡èœå•
                        });
                    } else {
                        this.contextMenuX = event.clientX + 'px';  // æ ¹æ®äº‹ä»¶ä½ç½®è®¾ç½®ä¸Šä¸‹æ–‡èœå•çš„æ¨ªåæ ‡
                        this.contextMenuY = event.clientY + 'px';  // æ ¹æ®äº‹ä»¶ä½ç½®è®¾ç½®ä¸Šä¸‹æ–‡èœå•çš„çºµåæ ‡
                        this.isContextMenuVisible = true;  // æ˜¾ç¤ºä¸Šä¸‹æ–‡èœå•
                    }
                    this.$emit('update-current-element', this.element);
                },

                closeContextMenu() {
                    this.isContextMenuVisible = false;
                },

                deleteElement(element) {
                    // ç¡®è®¤åˆ é™¤æ“ä½œ
                    if (confirm("Are you sure you want to delete this element?")) {
                        axios.get('{% url 'Statistic:delete_monitor' %}', {
                            params: {
                                element_id: element.id,
                                user_type: '{{ user_type }}',
                            }
                        })
                            .then(response => {
                                if (response.data && response.data.success) {
                                    console.log('Element deleted:', response.data.success);
                                    this.$emit('data-updated');
                                }
                            })
                            .catch(error => {
                                console.error('Error deleting layer:', error);
                            });
                    }
                    this.closeContextMenu();
                },

                openEditElement(element) {
                    this.$emit('update-current-element', element);
                    // è®¾ç½®è¡¨å•å­—æ®µçš„å€¼
                    setTimeout(() => {
                        const attrs = JSON.parse(element.data).attrs;
                        document.getElementById('editedElementName').value = element.name;
                        document.getElementById('editedTransformable').checked = element.transformable;
                        document.getElementById('editedIsOnline').checked = element.is_online;
                        document.getElementById('editedDraggable').checked = attrs.draggable;
                    }, 0); // ä½¿ç”¨ setTimeout ç¡®ä¿åœ¨ Vue çš„ DOM æ›´æ–°å®Œæˆåè®¾ç½®è¡¨å•å€¼
                    $('#editElementPropertiesModal').modal('show');
                },
            }
        });

        new Vue({
            el: '#monitor-app',
            delimiters: ['[[', ']]'], // æ›´æ”¹Vueçš„æ’å€¼è¡¨è¾¾å¼å®šç•Œç¬¦
            data: {
                currentSectorId: 0, // é»˜è®¤é¦–æ¬¡è®¿é—®çš„æ˜¯Current_Accessç¬¬ä¸€ä¸ªSector
                layers: [],
                monitors: [],
                currentLayer: null,
                currentElement: null,
                stage: null,
                offcanvasOpen: false,
                monitorImageUrl: "{% static 'data/Monitor/monitor.png' %}",
                imageSrc: null, // å­˜å‚¨ä¸Šä¼ çš„å›¾åƒçš„Data URL, è¿™ç”¨äºåœ¨æ·»åŠ å›¾åƒå…ƒç´ æ—¶ç›´æ¥åœ¨ç”»æ¿ä¸Šæ˜¾ç¤ºå›¾åƒ
                elementProps: null,
                processedImage: null,
                personCount: 0
            },
            mounted() {
                this.refreshData()
            },
            beforeDestroy() {
                if (this.stage) {
                    this.stage.container().removeEventListener('wheel', this.handleWheelZoom);
                }
                window.removeEventListener('resize', this.handleResize);
            },
            computed: {
                buttonStyle() {
                    return {
                        position: 'fixed',
                        bottom: '45vh',
                        left: this.offcanvasOpen ? '400px' : '10px', // Adjust '400px' as needed
                        zIndex: '1040',
                        width: '25px',
                        height: '50px',
                        display: 'flex',
                        justifyContent: 'center',
                        alignItems: 'center',
                        fontSize: '30px'
                    };
                }
            },
            methods: {
                // ----------------- æ•°æ®åŠ è½½ -----------------
                refreshData() {
                    console.log('Refreshing data...');
                    return axios.get('{% url "Statistic:refresh_data" %}', {
                        params: {
                            current_sector_id: this.currentSectorId,
                            current_access_id: {{ current_access.id }},
                            user_type: '{{ user_type }}',
                        }
                    }).then(response => {
                        if (response.data && response.data.id) {
                            console.log('Data synchronized:', response.data);
                            this.currentSectorId = response.data.id;
                            console.log('Current Sector ID:', this.currentSectorId);
                            this.renderData(response.data); // è°ƒç”¨renderDataæ¥å¤„ç†è¿™ä¸ªå•ä¸€èŠ‚ç‚¹
                            this.renderKonva(); // é‡æ–°åˆå§‹åŒ–Konva
                        } else {
                            console.error('Unexpected response data:', response.data);
                        }
                    }).catch(error => {
                        console.error('Failed to synchronize data:', error);
                    });
                },

                renderData(root) {
                    let queue = [root]; // åˆå§‹åŒ–é˜Ÿåˆ—ï¼Œèµ·å§‹ä¸ºæ ¹èŠ‚ç‚¹
                    this.layers = []; // æ¸…ç©ºVueå®ä¾‹çš„layersæ•°ç»„
                    this.layers = [root];
                    while (queue.length > 0) {
                        let currentLayer = queue.shift();  // è·å–å¹¶ç§»é™¤é˜Ÿåˆ—çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
                        //this.layers.push(currentLayer); // å°†å½“å‰å±‚æ·»åŠ åˆ°Vueå®ä¾‹çš„layersæ•°ç»„ä¸­
                        if (currentLayer.child_units && currentLayer.child_units.length > 0) { // å¦‚æœå½“å‰å±‚æœ‰å­å±‚ä¸”ä¸ä¸ºç©º
                            currentLayer.child_units.forEach(child => {
                                queue.push(child); // å°†å­å±‚æ·»åŠ åˆ°é˜Ÿåˆ—ä¸­ï¼Œä»¥ä¾¿åç»­å¤„ç†
                            });
                        }
                    }
                },

                // ----------------- ä»¥ä¸‹æ˜¯ä¸konva.jsç›¸å…³çš„å‡½æ•° -----------------

                // ----------------- konva.js: åŠ è½½æ•°æ® -----------------
                renderKonva() {
                    console.log('Rendering Konva...');
                    this.stage = new Konva.Stage({
                        container: 'konva-container',
                        width: window.innerWidth,
                        height: window.innerHeight,
                    });

                    // æ·»åŠ æ»šè½®ç¼©æ”¾äº‹ä»¶ç›‘å¬å™¨
                    this.stage.container().addEventListener('wheel', this.handleWheelZoom);
                    // æ·»åŠ çª—å£å¤§å°å˜åŒ–äº‹ä»¶ç›‘å¬å™¨
                    window.addEventListener('resize', this.handleResize);

                    const loadImage = (url, nodeData, group, element, spaceUnit, isMonitor) => { // ä¿è¯å›¾ç‰‡çš„åŒæ­¥è€Œéå¼‚æ­¥åŠ è½½, è¿™æ ·èƒ½å¤Ÿé¿å…å›¾å±‚çš„ä¹±åº
                        return new Promise((resolve, reject) => {
                            Konva.Image.fromURL(url, (imageNode) => {
                                try {
                                    imageNode.setAttrs(nodeData);
                                    group.add(imageNode);
                                    this.addListenersForElement(imageNode, element, spaceUnit, isMonitor);
                                    resolve(imageNode);
                                } catch (error) {
                                    reject(error);
                                }
                            });
                        });
                    };
                    this.monitors = [];
                    // é€’å½’å‡½æ•°æ¥å¤„ç†æ¯ä¸ªå±‚çº§çš„SpaceUnitå’Œelements
                    const processLayer = async (spaceUnits, parent) => {
                        for (const spaceUnit of spaceUnits) {
                            // ä½¿ç”¨Groupæ¥æ¨¡æ‹Ÿå±‚åµŒå¥—
                            let group = new Konva.Group();
                            parent.add(group); // å°†å½“å‰å±‚æ·»åŠ åˆ°çˆ¶ç»„ä»¶ä¸­

                            // å¤„ç†å½“å‰SpaceUnitçš„elements
                            for (const element of spaceUnit.elements) {
                                const nodeData = JSON.parse(element.data);
                                if (element.type === 'Image') { // å¦‚æœåŠ è½½çš„æ˜¯å›¾ç‰‡
                                    await loadImage(element.image, nodeData, group, element, spaceUnit, false);
                                } else {
                                    const node = Konva.Node.create(nodeData, group);
                                    group.add(node);
                                    this.addListenersForElement(node, element, spaceUnit, false); // æ·»åŠ å˜æ¢å’Œæ‹–æ‹½ç»“æŸçš„äº‹ä»¶ç›‘å¬å™¨
                                }
                            }

                            for (const element of spaceUnit.monitors) {
                                const nodeData = JSON.parse(element.data);
                                await loadImage(element.image, nodeData, group, element, spaceUnit, true);
                                this.monitors.push(element);
                            }

                            // å¦‚æœå½“å‰SpaceUnitæœ‰å­å•ä½ï¼Œåˆ™é€’å½’å¤„ç†
                            if (spaceUnit.child_units && spaceUnit.child_units.length > 0) {
                                await processLayer(spaceUnit.child_units, parent);
                            }
                        }
                    };

                    const rootLayer = new Konva.Layer();
                    this.stage.add(rootLayer);
                    processLayer(this.layers, rootLayer); // ä»æ ¹å±‚çº§å¼€å§‹å¤„ç†æ‰€æœ‰å±‚çº§
                    rootLayer.draw();
                },

                addListenersForElement(node, element, parentSpaceUnit, isMonitor) {
                    // æ·»åŠ å˜æ¢å’Œæ‹–æ‹½ç»“æŸçš„äº‹ä»¶ç›‘å¬å™¨
                    if (isMonitor) {
                        node.on('transformend dragend', () => {
                            let element = this.findElementByKonvaId(this.layers, node.id());
                            if (element) {
                                // æ›´æ–°å…ƒç´ å±æ€§
                                let data = JSON.parse(element.data);  // å°†JSONå­—ç¬¦ä¸²è½¬æ¢ä¸ºå¯¹è±¡
                                // æ›´æ–°å…ƒç´ å±æ€§
                                data.attrs.x = node.x();
                                data.attrs.y = node.y();
                                data.attrs.width = node.width();  // ä¹˜ä»¥scaleXå› ä¸ºå®½åº¦åœ¨å˜æ¢åå¯èƒ½è¢«ç¼©æ”¾
                                data.attrs.height = node.height();  // ä¹˜ä»¥scaleYå› ä¸ºé«˜åº¦åœ¨å˜æ¢åå¯èƒ½è¢«ç¼©æ”¾
                                data.attrs.rotation = node.rotation();
                                data.attrs.scaleX = node.scaleX();
                                data.attrs.scaleY = node.scaleY();
                                // å°†å¯¹è±¡è½¬æ¢å›JSONå­—ç¬¦ä¸²
                                element.data = JSON.stringify(data);
                            }
                            this.synchronizeElementsData();
                        });

                        if (element.transformable) {
                            const transformer = new Konva.Transformer({
                                node: node,
                                enabledAnchors: ['top-left', 'top-right', 'bottom-left', 'bottom-right', 'top-center', 'bottom-center', 'middle-left', 'middle-right'],
                                rotateEnabled: true,
                                keepRatio: true,
                                // æ—‹è½¬æŠŠæ‰‹åç§»é‡
                                rotateAnchorOffset: 60,
                                // å¯å˜å½¢æ“ä½œçš„è§†è§‰æ ·å¼
                                borderStroke: 'blue',
                                borderDash: [3, 3],
                                anchorStroke: 'grey',
                                anchorFill: 'grey',
                                anchorSize: 8,
                                borderStrokeWidth: 2
                            });
                            node.getLayer().add(transformer);
                            transformer.attachTo(node);
                        }

                        // æ·»åŠ å³é”®ç‚¹å‡»ç›‘å¬å™¨
                        node.on('contextmenu', (e) => {
                            e.evt.preventDefault();
                            let element = this.findElementByKonvaId(this.layers, node.id());
                            if (element) {
                                this.currentElement = element;
                                // è®¾ç½®è¡¨å•å­—æ®µçš„å€¼
                                setTimeout(() => {
                                    this.$emit('update-current-element', element);
                                    const attrs = JSON.parse(element.data).attrs;
                                    document.getElementById('editedElementName').value = element.name;
                                    document.getElementById('editedTransformable').checked = element.transformable;
                                    document.getElementById('editedIsOnline').checked = element.is_online;
                                    document.getElementById('editedDraggable').checked = attrs.draggable;
                                }, 0); // ä½¿ç”¨ setTimeout ç¡®ä¿åœ¨ Vue çš„ DOM æ›´æ–°å®Œæˆåè®¾ç½®è¡¨å•å€¼
                                $('#editElementPropertiesModal').modal('show');
                            }
                        });
                    }

                    const tooltip = document.getElementById('tooltip');
                    const showTooltip = (text, evt) => {
                        tooltip.style.display = 'block';
                        tooltip.innerText = text;
                        tooltip.style.backgroundColor = parentSpaceUnit.available ? 'green' : 'red'; // æ ¹æ® Available å±æ€§è®¾ç½®èƒŒæ™¯è‰²
                        const mousePos = this.stage.getPointerPosition();
                        tooltip.style.top = `${mousePos.y + 5}px`;
                        tooltip.style.left = `${mousePos.x + 5}px`;
                    };
                    const hideTooltip = () => {
                        tooltip.style.display = 'none';
                    };

                    // æ·»åŠ é¼ æ ‡æ‚¬æµ®äº‹ä»¶ç›‘å¬å™¨
                    node.on('mouseenter', (evt) => showTooltip(parentSpaceUnit.name, evt));
                    node.on('mouseleave', hideTooltip);
                    node.on('mousemove', (evt) => showTooltip(parentSpaceUnit.name, evt));
                },

                findElementByKonvaId(layers, elementId) {
                    for (let layer of layers) {
                        for (let element of layer.monitors) {
                            if (String(element.id) === String(elementId)) {
                                return element;
                            }
                        }
                        if (layer.child_units) {
                            let found = this.findElementByKonvaId(layer.child_units, elementId);
                            if (found) return found;
                        }
                    }
                    return null;
                },

                // ----------------- konva.js: æ•°æ®ä¸Šä¼  -----------------

                synchronizeElementsData() {
                    console.log('Synchronizing elements data...');
                    return axios.post('{% url 'Statistic:synchronize_monitors_data' %}', {
                        root: this.layers[0]
                    }).then(response => {
                        console.log('Data synchronized successfully:', response.data);
                    }).catch(error => {
                        console.error('Failed to synchronize elements data:', error);
                    });
                },

                uploadElement(newMonitor, elementProps) {
                    console.log('Uploading new monitor:', newMonitor.toJSON());
                    const {name, draggable, transformable, isOnline} = elementProps;
                    const formData = new FormData();
                    formData.append('name', name);
                    formData.append('is_online', isOnline);
                    formData.append('transformable', transformable);
                    formData.append('data', newMonitor.toJSON());
                    formData.append('layer_id', this.currentLayer.id);

                    axios.post('{% url "Statistic:add_monitor" %}', formData, {
                        headers: {
                            'Content-Type': 'multipart/form-data'
                        }
                    })
                        .then(response => {
                            console.log('Element added successfully:', response.data);
                            this.refreshData();
                            this.resetState(); // é‡ç½®æ·»åŠ çŠ¶æ€
                        })
                        .catch(error => {
                            console.error('Error adding element:', error);
                        });
                },

                editElementProperties() {
                    this.synchronizeElementsData().then(() => { // ç¡®ä¿åœ¨ä¿®æ”¹æ–°å…ƒç´ ååˆ·æ–°æœ¬åœ°æ•°æ®å‰æ›´æ–°ç”»æ¿ä¸Šçš„æ•°æ®åˆ°åç«¯
                        // const element = this.findElementByKonvaId(this.layers, this.currentElement.id)
                        const konvaElement = this.stage.findOne('#' + this.currentElement.id);
                        const draggable = document.getElementById('editedDraggable').checked;
                        const elementName = document.getElementById('editedElementName').value;
                        const transformable = document.getElementById('editedTransformable').checked;
                        const isOnline = document.getElementById('editedIsOnline').checked;
                        // æ›´æ–°KonvaElementçš„å±æ€§
                        konvaElement.draggable(draggable);

                        const formData = new FormData();
                        formData.append('id', this.currentElement.id);
                        formData.append('name', elementName);
                        formData.append('is_online', isOnline);
                        formData.append('transformable', transformable);
                        formData.append('data', konvaElement.toJSON());

                        console.log('Editing element:', konvaElement.toJSON());
                        axios.post('{% url "Statistic:edit_monitor" %}', formData, {
                            headers: {
                                'Content-Type': 'multipart/form-data'
                            }
                        })
                            .then(response => {
                                console.log('Element edited successfully:', response.data);
                                this.refreshData();
                                this.resetState(); // é‡ç½®æ·»åŠ çŠ¶æ€

                                // éšè—æ¨¡æ€æ¡†
                                $('#editElementPropertiesModal').modal('hide');
                            })
                            .catch(error => {
                                console.error('Error editing element:', error);
                            });
                    });
                },

                // ----------------- konva.js: æ§åˆ¶Stageä¸Šçš„äº¤äº’äº‹ä»¶ -----------------

                handleWheelZoom(event) {
                    // æ£€æŸ¥æ˜¯å¦æŒ‰ä¸‹äº†Ctrlé”®
                    if (event.ctrlKey) {
                        event.preventDefault();

                        const oldScale = this.stage.scaleX();
                        const pointer = this.stage.getPointerPosition();

                        // æ”¾å¤§æˆ–ç¼©å°
                        const scaleBy = 1.1;
                        const newScale = event.deltaY > 0 ? oldScale / scaleBy : oldScale * scaleBy;

                        this.stage.scale({x: newScale, y: newScale});

                        const mousePointTo = {
                            x: (pointer.x - this.stage.x()) / oldScale,
                            y: (pointer.y - this.stage.y()) / oldScale,
                        };

                        const newPos = {
                            x: pointer.x - mousePointTo.x * newScale,
                            y: pointer.y - mousePointTo.y * newScale,
                        };

                        this.stage.position(newPos);
                        this.stage.batchDraw();
                    }
                },

                handleStageClick(e) {
                    if (e.evt.button === 2) { // Right-click to finish polygon drawing
                        e.evt.preventDefault(); // é˜»æ­¢é»˜è®¤ä¸Šä¸‹æ–‡èœå•
                        this.resetState();
                    } else if (e.evt.button === 0) { // Left-click to add points
                        this.placeElement(this.elementProps, e);
                    }
                },

                handleResize() {
                    const width = window.innerWidth * 0.9;
                    const height = window.innerHeight * 0.91;
                    this.stage.size({width, height});
                },

                // ----------------- konva.js: æ·»åŠ Konva Elementåˆ°Stage -----------------

                addElement() {
                    this.offcanvasOpen = false; // å…ˆæ”¶ç¼©Offcanvas
                    $('#elementPropertiesModal').modal('show');
                },

                confirmElementProperties() {
                    const name = document.getElementById('elementName').value;
                    const transformable = document.getElementById('transformable').checked;
                    const draggable = document.getElementById('draggable').checked;
                    const isOnline = document.getElementById('isOnline').checked;

                    this.elementProps = {
                        name,
                        draggable: draggable,
                        transformable,
                        isOnline
                    };

                    // å…³é—­æ¨¡æ€æ¡†
                    $('#elementPropertiesModal').modal('hide');

                    document.getElementById('konva-container').style.cursor = 'crosshair';
                    // é˜»æ­¢ç”»å¸ƒçš„é»˜è®¤å³é”®èœå•
                    this.stage.container().addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                    });
                    this.stage.on('mousedown touchstart', this.handleStageClick);
                },

                resetState() {
                    this.stage.container().style.cursor = 'default'; // æ¢å¤é¼ æ ‡æ ·å¼
                    this.stage.off('mousedown touchstart'); // ç§»é™¤ç”»å¸ƒçš„ç‚¹å‡»äº‹ä»¶ç›‘å¬
                    this.currentLayer = null;
                    this.imageSrc = null; // æ¸…é™¤å›¾åƒæ•°æ®
                    this.elementProps = null;
                },

                placeElement(elementProps) {
                    const pos = this.stage.getPointerPosition();
                    let newElement;
                    const {name, draggable, transformable, isOnline} = elementProps;

                    const imageObj = new Image();
                    imageObj.src = this.monitorImageUrl;
                    imageObj.onload = () => {
                        newElement = new Konva.Image({
                            image: imageObj,
                            x: pos.x,
                            y: pos.y,
                            width: 150,
                            height: 100,
                            draggable: draggable,
                        });
                        this.synchronizeElementsData().then(() => { // ç¡®ä¿åœ¨åˆ›å»ºæ–°å…ƒç´ å‰æ›´æ–°æœ¬åœ°æ•°æ®åˆ°åç«¯
                            const konvaLayer = this.stage.getLayers()[0]; // è·å–stageä¸­çš„ç¬¬ä¸€ä¸ªLayer
                            konvaLayer.add(newElement);
                            konvaLayer.draw();
                            this.uploadElement(newElement, elementProps); // ä¸Šä¼ å…ƒç´ æ•°æ®åˆ°æœåŠ¡å™¨
                        });
                    };
                },

                // ----------------- Offcanvas -------------------------

                toggleOffcanvas() { // æ§åˆ¶ Offcanvas çš„æ˜¾ç¤ºä¸éšè—
                    this.offcanvasOpen = !this.offcanvasOpen;
                    let offcanvasElement = document.getElementById('offcanvasScrolling');
                    offcanvasElement.style.visibility = this.offcanvasOpen ? 'visible' : 'hidden';
                },

                toggleSector(sectorId) { // åˆ‡æ¢åŒºåŸŸ
                    if (this.layers[0].id !== sectorId) {
                        this.currentSectorId = sectorId;
                        this.refreshData();
                    }
                },

                // ----------------- Accordionçš„ç›¸å…³æ–¹æ³• -----------------

                setCurrentLayer(layer) {
                    console.log('Setting current layer:', layer);
                    this.currentLayer = layer;
                },

                setCurrentElement(element) {
                    console.log('Setting current element:', element);
                    this.currentElement = element;
                },
                
                // ----------------- API Demo Modalçš„ç›¸å…³æ–¹æ³• -------------------
                
                openApiDemoModal() {
                    let apiDemoModal = new bootstrap.Modal(document.getElementById('apiDemoModal'), {
                        keyboard: false
                    });
                    apiDemoModal.show();
                },
                
                handleFileUpload(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    this.uploadImageToServer(file);
                },
                
                uploadImageToServer(file) {
                    const formData = new FormData();
                    formData.append('image', file);
        
                    axios.post('{% url 'Statistic:recognize_flow' %}', formData, {
                        headers: {
                            'Content-Type': 'multipart/form-data'
                        }
                    })
                    .then(response => {
                        if (response.data.image) {
                            this.processedImage = response.data.image;
                            this.personCount = response.data.person_count;
                        }
                    })
                    .catch(error => {
                        console.error('Error processing image:', error);
                    });
                },
                
            }
        });

    </script>
{% endblock %}