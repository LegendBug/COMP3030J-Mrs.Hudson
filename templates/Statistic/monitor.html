{% extends 'Public/base.html' %}
{% load crispy_forms_filters %}
{% load crispy_forms_tags %}
{% load static %}

{% block extra_head %}
    <title>Monitor</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js"></script>
    <script src="https://unpkg.com/konva@9/konva.min.js"></script>

    <link rel="stylesheet" href="{% static 'css/Statistic/monitor.css' %}">
{% endblock %}

{% block extra_nav_icons %}
    <!-- 在这里添加导航栏里额外的icon-->
    {% if user.is_authenticated and user_type == 'Manager' %}
        <li class="nav-item">
            <a class="nav-link" href="{% url 'Statistic:statistic' %}"><i class="fas fa-chart-bar"></i> Statistics</a>
        </li>
        <li class="nav-item">
            <a class="nav-link" href="{% url 'Layout:layout' %}"><i class="fas fa-edit"></i> Layout</a>
        </li>
    {% endif %}
{% endblock %}

{% block breadcrumbs %}
    <nav aria-label="breadcrumb">
        <ol class="breadcrumb">
            <li class="breadcrumb-item"><a href="{% url 'Venue:home' %}">Home</a></li>
            {% if user.is_authenticated and user_type == 'Manager' %}
                <li class="breadcrumb-item"><a
                        href="{% url 'Venue:venue' current_access.id %}">{{ current_access.name }}</a></li>
            {% endif %}
            <li class="breadcrumb-item active" aria-current="page">Monitor</li>
        </ol>
    </nav>
{% endblock %}

{% block content %}
    <div id="monitor-app">
        <!-- Floating Action Button -->
        <button @click="toggleOffcanvas" class="btn btn-primary rounded shadow" id="toggle-offcanvas-btn"
                :style="buttonStyle">
            <i :class="offcanvasOpen ? 'fas fa-chevron-left' : 'fas fa-chevron-right'"></i>
        </button>
        
        <div class="d-flex justify-content-between align-items-center mb-3" id="venue-header">
            <div id="venue-name" class="venue-text logo-title">
                Current Venue: {{ current_access.name }}
            </div>
            <div class="dropdown">
                <button class="btn btn-secondary dropdown-toggle" type="button" id="dropdownFloorMenu"
                        data-bs-toggle="dropdown" aria-expanded="false">
                    Current Sector: [[ layers.length > 0 ? layers[0].name : 'Loading...' ]]
                </button>
                <ul class="dropdown-menu" aria-labelledby="dropdownFloorMenu">
                    {% for sector in sectors %}
                        {% comment %}你先别急, 这里是Pycharm的模板语法出现了问题, 这里其实是可以正常运行的{% endcomment %}
                        <li><a class="dropdown-item" href="#"
                               @click="toggleSector({{ sector.pk }})">Sector {{ sector.name }}</a></li>
                    {% endfor %}
                </ul>
            </div>
        </div>

        <div id="konva-container"></div>

        <!-- 用于展示在画板上选中的KonvaElement所在的Layer -->
        <div id="tooltip"
             style="position: absolute; display: none; background: lightgrey; padding: 5px; border-radius: 3px;"></div>

        <!-- Offcanvas -->
        <div class="offcanvas offcanvas-start" data-bs-scroll="true" data-bs-backdrop="false" id="offcanvasScrolling"
             tabindex="-1"
             aria-labelledby="offcanvasScrollingLabel"
             :class="{'show': offcanvasOpen}" style="visibility: visible;">

            <div class="offcanvas-header">
                {# Dropdown: Sector#}
                <div class="offcanvas-dropdown">
                    <button class="btn btn-secondary dropdown-toggle" type="button" id="dropdownSectorMenu"
                            data-bs-toggle="dropdown" aria-expanded="false">
                        Select Sector
                    </button>
                    <ul class="dropdown-menu" aria-labelledby="dropdownSectorMenu">
                        {% for sector in sectors %}
                            {% comment %}我知道你想debug,但这个错误不影响程序的正常运行,单纯是IDE对Django模板渲染的错误提示,你可以忽略它{% endcomment %}
                            <li><a class="dropdown-item" href="#"
                                   @click="toggleSector({{ sector.id }})">Sector {{ sector.name }}</a></li>
                        {% endfor %}
                    </ul>
                </div>

                {# 按钮: Save#}
                <button type="button" class="btn btn-primary" @click="synchronizeElementsData()">Save</button>
            </div>

            <div class="offcanvas-body">
                <!-- Top层级Accordion -->
                <div class="accordion" id="accordion">
                    <layer-component v-for="(layer, index) in layers" :key="layer.id" :layer="layer"
                                     @update-current-layer="setCurrentLayer" @update-current-element="setCurrentElement"
                                     @element-added="addElement" @data-updated="refreshData">
                    </layer-component>
                </div>
            </div>
        </div>
        
        <monitor-list :monitors="monitors" @open-api-modal="openApiDemoModal" @update-current-element="setCurrentElement"></monitor-list>

        <!-- Set Monitor Properties Modal -->
        <div class="modal fade" id="elementPropertiesModal" tabindex="-1" aria-labelledby="elementPropertiesModalLabel"
             aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="elementPropertiesModalLabel">Element Properties</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <!-- Form for element properties -->
                        <form id="elementPropertiesForm">
                            <!-- Element Name -->
                            <div class="mb-3">
                                <label for="elementName" class="form-label">Element Name</label>
                                <input type="text" id="elementName" class="form-control">
                            </div>
                            <!-- Is Online -->
                            <div class="mb-3 form-check">
                                <input type="checkbox" class="form-check-input" id="isOnline" checked>
                                <label class="form-check-label" for="isOnline">Is Online</label>
                            </div>
                            <!-- Transformable -->
                            <div class="mb-3 form-check">
                                <input type="checkbox" class="form-check-input" id="transformable" checked>
                                <label class="form-check-label" for="transformable">Transformable</label>
                            </div>
                            <!-- Draggable -->
                            <div class="mb-3 form-check">
                                <input type="checkbox" class="form-check-input" id="draggable" checked>
                                <label class="form-check-label" for="draggable">Draggable</label>
                            </div>
                        </form>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        <button type="button" class="btn btn-primary" @click="confirmElementProperties">Confirm</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Edit Monitor Properties Modal -->
        <div class="modal fade" id="editElementPropertiesModal" tabindex="-1"
             aria-labelledby="editElementPropertiesModalLabel" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="editElementPropertiesModalLabel">Edit Element Properties</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <!-- Form for element properties -->
                        <form id="editElementPropertiesForm">
                            <!-- Monitor Name -->
                            <div class="mb-3">
                                <label for="editedElementName" class="form-label">Element Name</label>
                                <input type="text" id="editedElementName" class="form-control">
                            </div>
                            <!-- Is Online -->
                            <div class="mb-3 form-check">
                                <input type="checkbox" class="form-check-input" id="editedIsOnline">
                                <label class="form-check-label" for="editedIsOnline">Is Online</label>
                            </div>
                            <!-- Transformable -->
                            <div class="mb-3 form-check">
                                <input type="checkbox" class="form-check-input" id="editedTransformable">
                                <label class="form-check-label" for="editedTransformable">Transformable</label>
                            </div>
                            <!-- Draggable -->
                            <div class="mb-3 form-check">
                                <input type="checkbox" class="form-check-input" id="editedDraggable">
                                <label class="form-check-label" for="editedDraggable">Draggable</label>
                            </div>
                        </form>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        <button type="button" class="btn btn-primary" @click="editElementProperties">Confirm</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- API Usage Modal -->
        <div class="modal fade" id="apiDemoModal" tabindex="-1" aria-labelledby="apiDemoModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="apiDemoModalLabel">API Usage Information</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div class="container">
                            <div class="card custom-modal"> <!-- 使用Card包裹 -->
                                <p class="text-muted lead">The pictures captured by the camera are sent to the corresponding API, and the deep learning model on the back end will process the pictures and count the traffic in the pictures.</p>

                                <div class="card-body">
                                  <p class="api-endpoint mb-2">You can use the API endpoint below to send images:</p>
                                  <p class="api-endpoint mb-4">POST: <a href="#" class="text-info"> https://hostname/Statistic/monitor/capture/[monitor_id]/</a></p>
                                </div>

                                <p class="test-recognition mt-4 mb-3">Test the recognition effect of the model by uploading a crowd picture of the venue below:</p>
                            </div>
                        </div>
                        
                        <!-- Image upload area -->
                        <div class="card border-primary mb-3" style="cursor: pointer;">
                            <div class="card-body text-center" @click="$refs.fileInput.click()">
                                <i class="fas fa-upload fa-2x text-primary"></i>
                                <p class="card-text text-secondary">Click or drag and drop an image here to upload.</p>
                                <input ref="fileInput" type="file" @change="handleFileUpload" accept="image/*" class="d-none" id="file-upload">
                            </div>
                        </div>
                        
                        <!-- Display processed image and results -->
                        <div v-if="processedImage">
                            <p class="mt-2" style="text-align: center"><strong>Detected persons:</strong> [[ personCount ]]</p>
                            <img :src="'data:image/jpeg;base64,' + processedImage" alt="Processed Image" class="img-fluid">
                        </div>
                    </div>
                </div>
            </div>
        </div>


    </div>

{% endblock %}

{% block scripts %}
    <script>
        Vue.component('monitor-list', {
            props: ['monitors'],
            delimiters: ['[[', ']]'], // 更改Vue的插值表达式定界符
            template: `
                <div class="table-responsive" style="margin: 1rem; user-select: none">
                    <table class="table table-hover text-white">
                        <thead class="bg-dark">
                        <tr>
                            <th>Monitor</th>
                            <th>Monitor Name</th>
                            <th>Sector</th>
                            <th>Status</th>
                            <th>API Url <i class="fas fa-question-circle" data-bs-toggle="modal" data-bs-target="#apiModal" @click="openApiDemoModal"></i></th>
                        </tr> 
                        </thead>
                        <tbody>
                        <tr v-for="monitor in monitors" :key="monitor.id" @click="editMonitor(monitor)" :class="{'table-success': monitor.is_online, 'table-warning': !monitor.is_online}" style="cursor: pointer;">
                            <td><img :src="monitor.image" alt="No image" class="monitor-img img-thumbnail"></td>
                            <td>[[ monitor.name ]]</td>
                            <td>[[ monitor.layer.name ]]</td>
                            <td>[[ monitor.is_online ? 'Online' : 'Offline' ]]</td>
                            <td>POST: <a href='#' class="text-info">https://hostname/Statistic/monitor/capture/[[ monitor.id ]]/</a></td>
                        </tr>
                        </tbody>
                    </table>
                </div>
            `,
            methods: {
                openApiDemoModal() {
                    this.$emit('open-api-modal');
                },
                
                editMonitor(monitor) {
                    this.$emit('update-current-element', monitor);
                    // 设置表单字段的值
                    setTimeout(() => {
                        const attrs = JSON.parse(monitor.data).attrs;
                        document.getElementById('editedElementName').value = monitor.name;
                        document.getElementById('editedTransformable').checked = monitor.transformable;
                        document.getElementById('editedIsOnline').checked = monitor.is_online;
                        document.getElementById('editedDraggable').checked = attrs.draggable;
                    }, 0); // 使用 setTimeout 确保在 Vue 的 DOM 更新完成后设置表单值
                    $('#editElementPropertiesModal').modal('show');
                },
            }
        });
    
        Vue.component('layer-component', {
            props: ['layer'],
            delimiters: ['[[', ']]'], // 更改Vue的插值表达式定界符
            data: function () {
                return {
                    open: false,  // 每个组件控制自己的打开状态
                    isContextMenuVisible: false,  // 上下文菜单是否可见
                    contextMenuX: '0px',  // 上下文菜单的X坐标
                    contextMenuY: '0px',   // 上下文菜单的Y坐标
                };
            },
            template: `
              <div class="accordion-item">
                <h2 class="accordion-header">
                  <button class="accordion-button" type="button"
                          :class="{'collapsed': !open}"
                          @click="open = !open;"
                          @contextmenu.prevent="openContextMenu($event, layer)"
                          style="background-color: #8bc0fa;">
                    [[ layer.name ]]
                  </button>
                </h2>
                <div v-if="open" class="accordion-collapse">
                  <div class="accordion-body">
                    <layer-component  v-for="(child, index) in layer.child_units" :key="index"
                                      :layer="child"
                                      @update-current-layer="$emit('update-current-layer', $event)"
                                      @update-current-element="$emit('update-current-element', $event)"
                                      @data-updated="$emit('data-updated', $event)" @element-added="$emit('element-added', $event)">
                    </layer-component>

                    <element-component  v-for="(element, index) in layer.monitors" :key="index"
                                        :element="element"
                                        @update-current-element="$emit('update-current-element', $event)"
                                        @data-updated="$emit('data-updated', $event)">
                    </element-component>
                  </div>
                </div>

                <!-- 上下文菜单 -->
                <div v-show="isContextMenuVisible" :style="{top: contextMenuY, left: contextMenuX}"
                     class="list-group context-menu">
                  <a class="list-group-item list-group-item-action" ref="addElementButton" @click="addElement(layer); closeContextMenu()">Add Monitor</a>
                </div>
              </div>
            `,
            mounted() {
                // 监听全局点击事件，用于隐藏上下文菜单
                document.addEventListener('click', this.handleOutsideClick);
            },
            beforeDestroy() {
                // 组件销毁前移除事件监听器，避免内存泄漏
                document.removeEventListener('click', this.handleOutsideClick);
            },
            methods: {
                handleOutsideClick(e) { // 全局点击事件处理
                    if (!e.target.closest('.context-menu')) {
                        this.isContextMenuVisible = false; // 使用 this 指向组件实例
                    }
                },

                openContextMenu(event) { // 上下文菜单事件处理
                    event.preventDefault();
                    if (this.isContextMenuVisible) {
                        this.isContextMenuVisible = false;
                        // 添加一个小延迟再显示新的菜单，以使菜单的隐藏和显示更加明显
                        this.$nextTick(() => {
                            this.contextMenuX = event.clientX + 'px';  // 根据事件位置设置上下文菜单的横坐标
                            this.contextMenuY = event.clientY + 'px';  // 根据事件位置设置上下文菜单的纵坐标
                            this.isContextMenuVisible = true;  // 显示上下文菜单
                        });
                    } else {
                        this.contextMenuX = event.clientX + 'px';  // 根据事件位置设置上下文菜单的横坐标
                        this.contextMenuY = event.clientY + 'px';  // 根据事件位置设置上下文菜单的纵坐标
                        this.isContextMenuVisible = true;  // 显示上下文菜单
                    }
                },

                closeContextMenu() {
                    this.isContextMenuVisible = false;  // 隐藏上下文菜单
                },

                addElement(layer) {
                    this.$emit('update-current-layer', layer);
                    this.$emit('element-added');
                }
            },
        });

        Vue.component('element-component', {
            props: ['element'],
            delimiters: ['[[', ']]'], // 更改Vue的插值表达式定界符
            data() {
                return {
                    open: false,
                    isContextMenuVisible: false, // 控制上下文菜单显示
                    contextMenuX: '0px', // 上下文菜单的横坐标
                    contextMenuY: '0px' // 上下文菜单的纵坐标
                };
            },
            template:
                `
              <div class="accordion-item">
                <h2 class="accordion-header">
                  <button class="accordion-button" type="button"
                          @contextmenu.prevent="openContextMenu($event)"
                          style="background-color: #e36767;">
                    [[ element.name ]]
                  </button>
                </h2>
                <!-- 上下文菜单 -->
                <div v-show="isContextMenuVisible" :style="{top: contextMenuY, left: contextMenuX}"
                     class="list-group context-menu">
                    <a class="list-group-item list-group-item-action" @click="openEditElement(element); closeContextMenu()">Edit Monitor</a>
                    <a class="list-group-item list-group-item-action" @click="deleteElement(element); closeContextMenu()">Delete Monitor</a>
                </div>
              </div>
            `,
            mounted() {
                // 监听全局点击事件，用于隐藏上下文菜单
                document.addEventListener('click', this.handleOutsideClick);
            },
            beforeDestroy() {
                // 组件销毁前移除事件监听器，避免内存泄漏
                document.removeEventListener('click', this.handleOutsideClick);
            },
            methods: {
                handleOutsideClick(e) { // 全局点击事件处理
                    if (!e.target.closest('.context-menu')) {
                        this.closeContextMenu();
                    }
                },

                openContextMenu(event) {
                    event.preventDefault();
                    if (this.isContextMenuVisible) {
                        this.isContextMenuVisible = false;
                        // 添加一个小延迟再显示新的菜单，以使菜单的隐藏和显示更加明显
                        this.$nextTick(() => {
                            this.contextMenuX = event.clientX + 'px';  // 根据事件位置设置上下文菜单的横坐标
                            this.contextMenuY = event.clientY + 'px';  // 根据事件位置设置上下文菜单的纵坐标
                            this.isContextMenuVisible = true;  // 显示上下文菜单
                        });
                    } else {
                        this.contextMenuX = event.clientX + 'px';  // 根据事件位置设置上下文菜单的横坐标
                        this.contextMenuY = event.clientY + 'px';  // 根据事件位置设置上下文菜单的纵坐标
                        this.isContextMenuVisible = true;  // 显示上下文菜单
                    }
                    this.$emit('update-current-element', this.element);
                },

                closeContextMenu() {
                    this.isContextMenuVisible = false;
                },

                deleteElement(element) {
                    // 确认删除操作
                    if (confirm("Are you sure you want to delete this element?")) {
                        axios.get('{% url 'Statistic:delete_monitor' %}', {
                            params: {
                                element_id: element.id,
                                user_type: '{{ user_type }}',
                            }
                        })
                            .then(response => {
                                if (response.data && response.data.success) {
                                    console.log('Element deleted:', response.data.success);
                                    this.$emit('data-updated');
                                }
                            })
                            .catch(error => {
                                console.error('Error deleting layer:', error);
                            });
                    }
                    this.closeContextMenu();
                },

                openEditElement(element) {
                    this.$emit('update-current-element', element);
                    // 设置表单字段的值
                    setTimeout(() => {
                        const attrs = JSON.parse(element.data).attrs;
                        document.getElementById('editedElementName').value = element.name;
                        document.getElementById('editedTransformable').checked = element.transformable;
                        document.getElementById('editedIsOnline').checked = element.is_online;
                        document.getElementById('editedDraggable').checked = attrs.draggable;
                    }, 0); // 使用 setTimeout 确保在 Vue 的 DOM 更新完成后设置表单值
                    $('#editElementPropertiesModal').modal('show');
                },
            }
        });

        new Vue({
            el: '#monitor-app',
            delimiters: ['[[', ']]'], // 更改Vue的插值表达式定界符
            data: {
                currentSectorId: 0, // 默认首次访问的是Current_Access第一个Sector
                layers: [],
                monitors: [],
                currentLayer: null,
                currentElement: null,
                stage: null,
                offcanvasOpen: false,
                monitorImageUrl: "{% static 'data/Monitor/monitor.png' %}",
                imageSrc: null, // 存储上传的图像的Data URL, 这用于在添加图像元素时直接在画板上显示图像
                elementProps: null,
                processedImage: null,
                personCount: 0
            },
            mounted() {
                this.refreshData()
            },
            beforeDestroy() {
                if (this.stage) {
                    this.stage.container().removeEventListener('wheel', this.handleWheelZoom);
                }
                window.removeEventListener('resize', this.handleResize);
            },
            computed: {
                buttonStyle() {
                    return {
                        position: 'fixed',
                        bottom: '45vh',
                        left: this.offcanvasOpen ? '400px' : '10px', // Adjust '400px' as needed
                        zIndex: '1040',
                        width: '25px',
                        height: '50px',
                        display: 'flex',
                        justifyContent: 'center',
                        alignItems: 'center',
                        fontSize: '30px'
                    };
                }
            },
            methods: {
                // ----------------- 数据加载 -----------------
                refreshData() {
                    console.log('Refreshing data...');
                    return axios.get('{% url "Statistic:refresh_data" %}', {
                        params: {
                            current_sector_id: this.currentSectorId,
                            current_access_id: {{ current_access.id }},
                            user_type: '{{ user_type }}',
                        }
                    }).then(response => {
                        if (response.data && response.data.id) {
                            console.log('Data synchronized:', response.data);
                            this.currentSectorId = response.data.id;
                            console.log('Current Sector ID:', this.currentSectorId);
                            this.renderData(response.data); // 调用renderData来处理这个单一节点
                            this.renderKonva(); // 重新初始化Konva
                        } else {
                            console.error('Unexpected response data:', response.data);
                        }
                    }).catch(error => {
                        console.error('Failed to synchronize data:', error);
                    });
                },

                renderData(root) {
                    let queue = [root]; // 初始化队列，起始为根节点
                    this.layers = []; // 清空Vue实例的layers数组
                    this.layers = [root];
                    while (queue.length > 0) {
                        let currentLayer = queue.shift();  // 获取并移除队列的第一个元素
                        //this.layers.push(currentLayer); // 将当前层添加到Vue实例的layers数组中
                        if (currentLayer.child_units && currentLayer.child_units.length > 0) { // 如果当前层有子层且不为空
                            currentLayer.child_units.forEach(child => {
                                queue.push(child); // 将子层添加到队列中，以便后续处理
                            });
                        }
                    }
                },

                // ----------------- 以下是与konva.js相关的函数 -----------------

                // ----------------- konva.js: 加载数据 -----------------
                renderKonva() {
                    console.log('Rendering Konva...');
                    this.stage = new Konva.Stage({
                        container: 'konva-container',
                        width: window.innerWidth * 0.9,
                        height: window.innerHeight * 0.91,
                    });

                    // 添加滚轮缩放事件监听器
                    this.stage.container().addEventListener('wheel', this.handleWheelZoom);
                    // 添加窗口大小变化事件监听器
                    window.addEventListener('resize', this.handleResize);
                    // 添加画板拖拽的监听器
                    this.stage.on('mousedown', this.handleMouseDown);
                    this.stage.on('mouseup', this.handleMouseUp);
                    this.stage.on('mousemove', this.handleMouseMove);

                    const loadImage = (url, nodeData, group, element, spaceUnit, isMonitor) => { // 保证图片的同步而非异步加载, 这样能够避免图层的乱序
                        return new Promise((resolve, reject) => {
                            Konva.Image.fromURL(url, (imageNode) => {
                                try {
                                    imageNode.setAttrs(nodeData);
                                    group.add(imageNode);
                                    this.addListenersForElement(imageNode, element, spaceUnit, isMonitor);
                                    resolve(imageNode);
                                } catch (error) {
                                    reject(error);
                                }
                            });
                        });
                    };
                    this.monitors = [];
                    // 递归函数来处理每个层级的SpaceUnit和elements
                    const processLayer = async (spaceUnits, parent) => {
                        for (const spaceUnit of spaceUnits) {
                            // 使用Group来模拟层嵌套
                            let group = new Konva.Group();
                            parent.add(group); // 将当前层添加到父组件中

                            // 处理当前SpaceUnit的elements
                            for (const element of spaceUnit.elements) {
                                const nodeData = JSON.parse(element.data);
                                if (element.type === 'Image') { // 如果加载的是图片
                                    await loadImage(element.image, nodeData, group, element, spaceUnit, false);
                                } else {
                                    const node = Konva.Node.create(nodeData, group);
                                    group.add(node);
                                    this.addListenersForElement(node, element, spaceUnit, false); // 添加变换和拖拽结束的事件监听器
                                }
                            }

                            for (const element of spaceUnit.monitors) {
                                const nodeData = JSON.parse(element.data);
                                await loadImage(element.image, nodeData, group, element, spaceUnit, true);
                                this.monitors.push(element);
                            }

                            // 如果当前SpaceUnit有子单位，则递归处理
                            if (spaceUnit.child_units && spaceUnit.child_units.length > 0) {
                                await processLayer(spaceUnit.child_units, parent);
                            }
                        }
                    };

                    const rootLayer = new Konva.Layer();
                    this.stage.add(rootLayer);
                    processLayer(this.layers, rootLayer); // 从根层级开始处理所有层级
                    rootLayer.draw();
                },

                addListenersForElement(node, element, parentSpaceUnit, isMonitor) {
                    // 添加变换和拖拽结束的事件监听器
                    if (isMonitor) {
                        node.on('transformend dragend', () => {
                            let element = this.findElementByKonvaId(this.layers, node.id());
                            if (element) {
                                // 更新元素属性
                                let data = JSON.parse(element.data);  // 将JSON字符串转换为对象
                                // 更新元素属性
                                data.attrs.x = node.x();
                                data.attrs.y = node.y();
                                data.attrs.width = node.width();  // 乘以scaleX因为宽度在变换后可能被缩放
                                data.attrs.height = node.height();  // 乘以scaleY因为高度在变换后可能被缩放
                                data.attrs.rotation = node.rotation();
                                data.attrs.scaleX = node.scaleX();
                                data.attrs.scaleY = node.scaleY();
                                // 将对象转换回JSON字符串
                                element.data = JSON.stringify(data);
                            }
                            this.synchronizeElementsData();
                        });

                        if (element.transformable) {
                            const transformer = new Konva.Transformer({
                                node: node,
                                enabledAnchors: ['top-left', 'top-right', 'bottom-left', 'bottom-right', 'top-center', 'bottom-center', 'middle-left', 'middle-right'],
                                rotateEnabled: true,
                                keepRatio: true,
                                // 旋转把手偏移量
                                rotateAnchorOffset: 60,
                                // 可变形操作的视觉样式
                                borderStroke: 'blue',
                                borderDash: [3, 3],
                                anchorStroke: 'grey',
                                anchorFill: 'grey',
                                anchorSize: 8,
                                borderStrokeWidth: 2
                            });
                            node.getLayer().add(transformer);
                            transformer.attachTo(node);
                        }

                        // 添加右键点击监听器
                        node.on('contextmenu', (e) => {
                            e.evt.preventDefault();
                            let element = this.findElementByKonvaId(this.layers, node.id());
                            if (element) {
                                this.currentElement = element;
                                // 设置表单字段的值
                                setTimeout(() => {
                                    this.$emit('update-current-element', element);
                                    const attrs = JSON.parse(element.data).attrs;
                                    document.getElementById('editedElementName').value = element.name;
                                    document.getElementById('editedTransformable').checked = element.transformable;
                                    document.getElementById('editedIsOnline').checked = element.is_online;
                                    document.getElementById('editedDraggable').checked = attrs.draggable;
                                }, 0); // 使用 setTimeout 确保在 Vue 的 DOM 更新完成后设置表单值
                                $('#editElementPropertiesModal').modal('show');
                            }
                        });
                    }

                    const tooltip = document.getElementById('tooltip');
                    const showTooltip = (text, evt) => {
                        tooltip.style.display = 'block';
                        tooltip.innerText = text;
                        tooltip.style.backgroundColor = parentSpaceUnit.available ? 'green' : 'red'; // 根据 Available 属性设置背景色
                        const mousePos = this.stage.getPointerPosition();
                        tooltip.style.top = `${mousePos.y + 5}px`;
                        tooltip.style.left = `${mousePos.x + 5}px`;
                    };
                    const hideTooltip = () => {
                        tooltip.style.display = 'none';
                    };

                    // 添加鼠标悬浮事件监听器
                    node.on('mouseenter', (evt) => showTooltip(parentSpaceUnit.name, evt));
                    node.on('mouseleave', hideTooltip);
                    node.on('mousemove', (evt) => showTooltip(parentSpaceUnit.name, evt));
                },

                findElementByKonvaId(layers, elementId) {
                    for (let layer of layers) {
                        for (let element of layer.monitors) {
                            if (String(element.id) === String(elementId)) {
                                return element;
                            }
                        }
                        if (layer.child_units) {
                            let found = this.findElementByKonvaId(layer.child_units, elementId);
                            if (found) return found;
                        }
                    }
                    return null;
                },

                // ----------------- konva.js: 数据上传 -----------------

                synchronizeElementsData() {
                    console.log('Synchronizing elements data...');
                    return axios.post('{% url 'Statistic:synchronize_monitors_data' %}', {
                        root: this.layers[0]
                    }).then(response => {
                        console.log('Data synchronized successfully:', response.data);
                    }).catch(error => {
                        console.error('Failed to synchronize elements data:', error);
                    });
                },

                uploadElement(newMonitor, elementProps) {
                    console.log('Uploading new monitor:', newMonitor.toJSON());
                    const {name, draggable, transformable, isOnline} = elementProps;
                    const formData = new FormData();
                    formData.append('name', name);
                    formData.append('is_online', isOnline);
                    formData.append('transformable', transformable);
                    formData.append('data', newMonitor.toJSON());
                    formData.append('layer_id', this.currentLayer.id);

                    axios.post('{% url "Statistic:add_monitor" %}', formData, {
                        headers: {
                            'Content-Type': 'multipart/form-data'
                        }
                    })
                        .then(response => {
                            console.log('Element added successfully:', response.data);
                            this.refreshData();
                            this.resetState(); // 重置添加状态
                        })
                        .catch(error => {
                            console.error('Error adding element:', error);
                        });
                },

                editElementProperties() {
                    this.synchronizeElementsData().then(() => { // 确保在修改新元素后刷新本地数据前更新画板上的数据到后端
                        // const element = this.findElementByKonvaId(this.layers, this.currentElement.id)
                        const konvaElement = this.stage.findOne('#' + this.currentElement.id);
                        const draggable = document.getElementById('editedDraggable').checked;
                        const elementName = document.getElementById('editedElementName').value;
                        const transformable = document.getElementById('editedTransformable').checked;
                        const isOnline = document.getElementById('editedIsOnline').checked;
                        // 更新KonvaElement的属性
                        konvaElement.draggable(draggable);

                        const formData = new FormData();
                        formData.append('id', this.currentElement.id);
                        formData.append('name', elementName);
                        formData.append('is_online', isOnline);
                        formData.append('transformable', transformable);
                        formData.append('data', konvaElement.toJSON());

                        console.log('Editing element:', konvaElement.toJSON());
                        axios.post('{% url "Statistic:edit_monitor" %}', formData, {
                            headers: {
                                'Content-Type': 'multipart/form-data'
                            }
                        })
                            .then(response => {
                                console.log('Element edited successfully:', response.data);
                                this.refreshData();
                                this.resetState(); // 重置添加状态

                                // 隐藏模态框
                                $('#editElementPropertiesModal').modal('hide');
                            })
                            .catch(error => {
                                console.error('Error editing element:', error);
                            });
                    });
                },

                // ----------------- konva.js: 控制Stage上的交互事件 -----------------

                handleMouseDown(e) {
                    // 确保是左键点击
                    if (e.evt.button === 0) {
                        this.isDragging = true;
                        this.lastPointerPosition = this.stage.getPointerPosition();
                    }
                },

                handleMouseUp() {
                    this.isDragging = false; // 停止拖动
                },

                handleMouseMove(e) {
                    if (this.isDragging) {
                        // 计算移动距离
                        const pointerPosition = this.stage.getPointerPosition();
                        const dx = pointerPosition.x - this.lastPointerPosition.x;
                        const dy = pointerPosition.y - this.lastPointerPosition.y;

                        // 更新位置
                        this.stage.x(this.stage.x() + dx);
                        this.stage.y(this.stage.y() + dy);

                        // 更新最后的指针位置
                        this.lastPointerPosition = pointerPosition;

                        // 重新渲染
                        this.stage.batchDraw();
                    }
                },

                handleWheelZoom(event) {
                    // 检查是否按下了Ctrl键
                    if (event.ctrlKey) {
                        event.preventDefault();

                        const oldScale = this.stage.scaleX();
                        const pointer = this.stage.getPointerPosition();

                        // 放大或缩小
                        const scaleBy = 1.1;
                        const newScale = event.deltaY > 0 ? oldScale / scaleBy : oldScale * scaleBy;

                        this.stage.scale({x: newScale, y: newScale});

                        const mousePointTo = {
                            x: (pointer.x - this.stage.x()) / oldScale,
                            y: (pointer.y - this.stage.y()) / oldScale,
                        };

                        const newPos = {
                            x: pointer.x - mousePointTo.x * newScale,
                            y: pointer.y - mousePointTo.y * newScale,
                        };

                        this.stage.position(newPos);
                        this.stage.batchDraw();
                    }
                },

                handleStageClick(e) {
                    if (e.evt.button === 2) { // Right-click to finish polygon drawing
                        e.evt.preventDefault(); // 阻止默认上下文菜单
                        this.resetState();
                    } else if (e.evt.button === 0) { // Left-click to add points
                        this.placeElement(this.elementProps, e);
                    }
                },

                handleResize() {
                    const width = window.innerWidth * 0.9;
                    const height = window.innerHeight * 0.91;
                    this.stage.size({width, height});
                },

                // ----------------- konva.js: 添加Konva Element到Stage -----------------

                addElement() {
                    this.offcanvasOpen = false; // 先收缩Offcanvas
                    $('#elementPropertiesModal').modal('show');
                },

                confirmElementProperties() {
                    const name = document.getElementById('elementName').value;
                    const transformable = document.getElementById('transformable').checked;
                    const draggable = document.getElementById('draggable').checked;
                    const isOnline = document.getElementById('isOnline').checked;

                    this.elementProps = {
                        name,
                        draggable: draggable,
                        transformable,
                        isOnline
                    };

                    // 关闭模态框
                    $('#elementPropertiesModal').modal('hide');

                    document.getElementById('konva-container').style.cursor = 'crosshair';
                    // 阻止画布的默认右键菜单
                    this.stage.container().addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                    });
                    this.stage.on('mousedown touchstart', this.handleStageClick);
                },

                resetState() {
                    this.stage.container().style.cursor = 'default'; // 恢复鼠标样式
                    this.stage.off('mousedown touchstart'); // 移除画布的点击事件监听
                    this.currentLayer = null;
                    this.imageSrc = null; // 清除图像数据
                    this.elementProps = null;
                },

                placeElement(elementProps) {
                    const pos = this.stage.getPointerPosition();
                    let newElement;
                    const {name, draggable, transformable, isOnline} = elementProps;

                    const imageObj = new Image();
                    imageObj.src = this.monitorImageUrl;
                    imageObj.onload = () => {
                        newElement = new Konva.Image({
                            image: imageObj,
                            x: pos.x,
                            y: pos.y,
                            width: 150,
                            height: 100,
                            draggable: draggable,
                        });
                        this.synchronizeElementsData().then(() => { // 确保在创建新元素前更新本地数据到后端
                            const konvaLayer = this.stage.getLayers()[0]; // 获取stage中的第一个Layer
                            konvaLayer.add(newElement);
                            konvaLayer.draw();
                            this.uploadElement(newElement, elementProps); // 上传元素数据到服务器
                        });
                    };
                },

                // ----------------- Offcanvas -------------------------

                toggleOffcanvas() { // 控制 Offcanvas 的显示与隐藏
                    this.offcanvasOpen = !this.offcanvasOpen;
                    let offcanvasElement = document.getElementById('offcanvasScrolling');
                    offcanvasElement.style.visibility = this.offcanvasOpen ? 'visible' : 'hidden';
                },

                toggleSector(sectorId) { // 切换区域
                    if (this.layers[0].id !== sectorId) {
                        this.currentSectorId = sectorId;
                        this.refreshData();
                    }
                },

                // ----------------- Accordion的相关方法 -----------------

                setCurrentLayer(layer) {
                    console.log('Setting current layer:', layer);
                    this.currentLayer = layer;
                },

                setCurrentElement(element) {
                    console.log('Setting current element:', element);
                    this.currentElement = element;
                },
                
                // ----------------- API Demo Modal的相关方法 -------------------
                
                openApiDemoModal() {
                    let apiDemoModal = new bootstrap.Modal(document.getElementById('apiDemoModal'), {
                        keyboard: false
                    });
                    apiDemoModal.show();
                },
                
                handleFileUpload(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    this.uploadImageToServer(file);
                },
                
                uploadImageToServer(file) {
                    const formData = new FormData();
                    formData.append('image', file);
        
                    axios.post('{% url 'Statistic:recognize_flow' %}', formData, {
                        headers: {
                            'Content-Type': 'multipart/form-data'
                        }
                    })
                    .then(response => {
                        if (response.data.image) {
                            this.processedImage = response.data.image;
                            this.personCount = response.data.person_count;
                        }
                    })
                    .catch(error => {
                        console.error('Error processing image:', error);
                    });
                },
                
            }
        });

    </script>
{% endblock %}